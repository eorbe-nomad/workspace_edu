
## 리포지토리 개요

이 리포지토리는 매우 작은 C 예제입니다. 단일 소스 파일 `hello.c`가 있으며 표준 출력으로 "Hello, C!"를 출력합니다.

핵심 파일:

- `hello.c` — 단일 파일 CLI 프로그램. `<stdio.h>` 포함, `int main()`에서 `printf("Hello, C!\n");` 호출.

## 전체 구조(핵심 요약)

멀티 모듈 아키텍처는 없습니다. 현재 모든 작업은 `hello.c`에 국한됩니다. 기능을 확장할 때는 최소한의 추가를 권장합니다 — 예: `Makefile` 또는 `src/`, `tests/` 같은 작은 디렉터리 구조를 선호하세요.

## 빌드 및 실행(개발자 워크플로)

다음 예시는 Windows PowerShell 환경을 기준으로 합니다. 사용자는 선호하는 툴체인을 사용하면 됩니다.

- GCC (MinGW, MSYS, WSL):

  ```powershell
  gcc -o hello.exe hello.c
  .\hello.exe
  ```

  디버그 심볼과 경고를 포함하려면:

  ```powershell
  gcc -g -Wall -Wextra -o hello.exe hello.c
  ```

- Microsoft Visual C (cl.exe, Developer Command Prompt 사용):

  ```powershell
  cl /Zi /W3 /Fe:hello.exe hello.c
  .\hello.exe
  ```

빌드 시스템(예: `Makefile`, `CMakeLists.txt`)을 추가하면, 해당 명령을 이 파일과 `README.md`에 명확히 문서화하세요.

## 테스트 및 디버깅

- 현재 테스트는 없습니다. 유닛 테스트를 추가할 경우 `tests/` 폴더를 만들고 간단한 실행러(예: Makefile 또는 CTest)를 사용하세요.
- 네이티브 디버깅은 `gdb`(GCC) 또는 Visual Studio 디버거(cl)를 사용하세요. GCC는 `-g`, MSVC는 `/Zi`로 컴파일합니다.

## 프로젝트 규약 및 패턴

- 코드를 간결하고 자기 포함형으로 유지하세요. 현재 `hello.c`는 매우 짧고 간단합니다 — 변경 시 읽기 쉬운 레이아웃(가능하면 한 줄에 한 문장)을 유지하세요.
- 기능을 분리할 때는 명확하게: 소스는 `src/`, 헤더는 `include/`, 테스트는 `tests/`로 분리합니다.

예시:

- `hello.c`는 `printf("Hello, C!\n");`를 사용합니다. 기본 입출력에는 표준 라이브러리를 우선 사용하세요.

## 통합 포인트 및 의존성

- 현재는 C 표준 라이브러리만 사용합니다. 외부 서비스나 라이브러리, CI 구성은 없습니다.

외부 의존성을 추가하면 설치 단계(예: 패키지 매니저, 링크)를 `README.md`와 이 파일에 문서화하세요.

## AI 에이전트(코딩 어시스턴트)를 위한 실무 안내

- 작업은 리포지토리 루트에서 수행하세요. `hello.c`를 수정하면 빌드하고 실행해 결과를 확인한 뒤 변경을 보고하세요.
- 변경은 최소한으로 하고 되돌리기 쉬운 방식으로 만드세요. 파일을 추가할 때는 `README.md`에 간단한 사용법을 함께 추가하세요.
- 대규모 빌드 시스템(CMake, Meson 등)을 도입하기 전에는 반드시 사람에게 확인을 요청하세요.

추가로 불확실한 점이 있으면 명확히 질문하세요 (예: "단일 파일 예제 상태를 유지하길 원하십니까, 아니면 Makefile을 추가할까요?").

---

참고: 계정을 변경할 예정이라고 하셨는데, 계정 관련 설정(예: 리포지토리 접근, CI 연동, 배포 토큰)이 필요한 경우 알려주시면 안내 문서와 설정 내용을 업데이트하겠습니다.

원하시면 아래 작업을 추가로 수행해 드립니다:

- 최소한의 `Makefile` 또는 `CMakeLists.txt` 추가 및 명령 문서화
- `README.md` 생성(빌드/실행/테스트 예시 포함)
- `src/` + `include/` + `tests/` 레이아웃으로 확장

원하시는 방향을 알려주세요.
